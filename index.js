// Generated by Haxe 4.0.0
(function () { "use strict";
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
Math.__name__ = true;
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if((o instanceof Array)) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			var e1 = (e instanceof js__$Boot_HaxeError) ? e.val : e;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var polyline_Extensions = function() { };
polyline_Extensions.__name__ = true;
polyline_Extensions.unsafeGet = function(array,index) {
	return array[index];
};
polyline_Extensions.unsafeSet = function(array,index,value) {
	array[index] = value;
};
var polyline_MiterUtils = function() {
	this.tmpY = 0;
	this.tmpX = 0;
	this.outY = 0;
	this.outX = 0;
	this.bY = 0;
	this.bX = 0;
	this.aY = 0;
	this.aX = 0;
	this.miterY = 0;
	this.miterX = 0;
	this.tangentY = 0;
	this.tangentX = 0;
};
polyline_MiterUtils.__name__ = true;
polyline_MiterUtils.prototype = {
	computeMiter: function(halfThick) {
		this.tangentX = this.aX + this.bX;
		this.tangentY = this.aY + this.bY;
		this.miterX = -this.tangentY;
		this.miterY = this.tangentX;
		this.tmpX = -this.aY;
		this.tmpY = this.aX;
		return halfThick / (this.miterX * this.tmpX + this.miterY * this.tmpY);
	}
	,normal: function(dirX,dirY) {
		this.outX = -dirY;
		this.outY = dirX;
	}
	,direction: function() {
		this.outX = this.aX - this.bX;
		this.outY = this.aY - this.bY;
		var len = this.outX * this.outX + this.outY * this.outY;
		if(len > 0) {
			len = 1.0 / Math.sqrt(len);
			this.outX *= len;
			this.outY *= len;
		}
	}
};
var polyline_Stroke = function() {
	this._started = false;
	this._lastFlip = -1;
	this._normalY = 0;
	this._normalX = 0;
	this._hasNormal = false;
	this.capEndY = 0;
	this.capEndX = 0;
	this.miterY = 0;
	this.miterX = 0;
	this.tangentY = 0;
	this.tangentX = 0;
	this.lineBY = 0;
	this.lineBX = 0;
	this.lineAY = 0;
	this.lineAX = 0;
	this.tmpY = 0;
	this.tmpX = 0;
	this.cap = polyline_StrokeCap.BUTT;
	this.join = polyline_StrokeJoin.MITER;
	this.thickness = 1;
	this.miterLimit = 10;
};
polyline_Stroke.__name__ = true;
polyline_Stroke.prototype = {
	build: function(points,vertices,indices) {
		if(vertices.length > 0) {
			vertices.splice(0,vertices.length);
		}
		if(indices.length > 0) {
			indices.splice(0,indices.length);
		}
		if(points.length == 0) {
			return;
		}
		var total = points.length;
		this._lastFlip = -1;
		this._started = false;
		this._hasNormal = false;
		var i = 2;
		var count = 0;
		while(i < total) {
			var lastX = points[i - 2];
			var lastY = points[i - 1];
			var curX = points[i];
			var curY = points[i + 1];
			var nextX = -9999999999.0;
			var nextY = -9999999999.0;
			if(i < total - 2) {
				nextX = points[i + 2];
				nextY = points[i + 3];
			}
			var thickness = this.mapThickness(curX,curY,i,points);
			var lastX1 = lastX;
			var lastY1 = lastY;
			var curX1 = curX;
			var curY1 = curY;
			var halfThick = thickness * 0.5;
			var count1 = 0;
			var capSquare = this.cap == polyline_StrokeCap.SQUARE;
			var joinBevel = this.join == polyline_StrokeJoin.BEVEL;
			polyline_Stroke.miterUtils.aX = curX1;
			polyline_Stroke.miterUtils.aY = curY1;
			polyline_Stroke.miterUtils.bX = lastX1;
			polyline_Stroke.miterUtils.bY = lastY1;
			var _this = polyline_Stroke.miterUtils;
			_this.outX = _this.aX - _this.bX;
			_this.outY = _this.aY - _this.bY;
			var len = _this.outX * _this.outX + _this.outY * _this.outY;
			if(len > 0) {
				len = 1.0 / Math.sqrt(len);
				_this.outX *= len;
				_this.outY *= len;
			}
			this.lineAX = polyline_Stroke.miterUtils.outX;
			this.lineAY = polyline_Stroke.miterUtils.outY;
			if(!this._hasNormal) {
				var _this1 = polyline_Stroke.miterUtils;
				_this1.outX = -this.lineAY;
				_this1.outY = this.lineAX;
				this._normalX = polyline_Stroke.miterUtils.outX;
				this._normalY = polyline_Stroke.miterUtils.outY;
				this._hasNormal = true;
			}
			if(!this._started) {
				this._started = true;
				if(capSquare) {
					this.capEndX = lastX1 + this.lineAX * -halfThick;
					this.capEndY = lastY1 + this.lineAY * -halfThick;
					lastX1 = this.capEndX;
					lastY1 = this.capEndY;
				}
				var normalX = this._normalX;
				var normalY = this._normalY;
				this.tmpX = lastX1 + normalX * -halfThick;
				this.tmpY = lastY1 + normalY * -halfThick;
				vertices.push(this.tmpX);
				vertices.push(this.tmpY);
				this.tmpX = lastX1 + normalX * halfThick;
				this.tmpY = lastY1 + normalY * halfThick;
				vertices.push(this.tmpX);
				vertices.push(this.tmpY);
			}
			indices.push(count);
			indices.push(count + 1);
			indices.push(count + 2);
			if(nextX == -9999999999.0) {
				var _this2 = polyline_Stroke.miterUtils;
				_this2.outX = -this.lineAY;
				_this2.outY = this.lineAX;
				this._normalX = polyline_Stroke.miterUtils.outX;
				this._normalY = polyline_Stroke.miterUtils.outY;
				this._hasNormal = true;
				if(capSquare) {
					this.capEndX = curX1 + this.lineAX * halfThick;
					this.capEndY = curY1 + this.lineAY * halfThick;
					curX1 = this.capEndX;
					curY1 = this.capEndY;
				}
				var normalX1 = this._normalX;
				var normalY1 = this._normalY;
				this.tmpX = curX1 + normalX1 * -halfThick;
				this.tmpY = curY1 + normalY1 * -halfThick;
				vertices.push(this.tmpX);
				vertices.push(this.tmpY);
				this.tmpX = curX1 + normalX1 * halfThick;
				this.tmpY = curY1 + normalY1 * halfThick;
				vertices.push(this.tmpX);
				vertices.push(this.tmpY);
				if(this._lastFlip == 1) {
					indices.push(count);
					indices.push(count + 2);
					indices.push(count + 3);
				} else {
					indices.push(count + 2);
					indices.push(count + 1);
					indices.push(count + 3);
				}
				count1 += 2;
			} else {
				polyline_Stroke.miterUtils.aX = nextX;
				polyline_Stroke.miterUtils.aY = nextY;
				polyline_Stroke.miterUtils.bX = curX1;
				polyline_Stroke.miterUtils.bY = curY1;
				var _this3 = polyline_Stroke.miterUtils;
				_this3.outX = _this3.aX - _this3.bX;
				_this3.outY = _this3.aY - _this3.bY;
				var len1 = _this3.outX * _this3.outX + _this3.outY * _this3.outY;
				if(len1 > 0) {
					len1 = 1.0 / Math.sqrt(len1);
					_this3.outX *= len1;
					_this3.outY *= len1;
				}
				this.lineBX = polyline_Stroke.miterUtils.outX;
				this.lineBY = polyline_Stroke.miterUtils.outY;
				polyline_Stroke.miterUtils.tangentX = this.tangentX;
				polyline_Stroke.miterUtils.tangentY = this.tangentY;
				polyline_Stroke.miterUtils.miterX = this.miterX;
				polyline_Stroke.miterUtils.miterY = this.miterY;
				polyline_Stroke.miterUtils.aX = this.lineAX;
				polyline_Stroke.miterUtils.aY = this.lineAY;
				polyline_Stroke.miterUtils.bX = this.lineBX;
				polyline_Stroke.miterUtils.bY = this.lineBY;
				var _this4 = polyline_Stroke.miterUtils;
				_this4.tangentX = _this4.aX + _this4.bX;
				_this4.tangentY = _this4.aY + _this4.bY;
				_this4.miterX = -_this4.tangentY;
				_this4.miterY = _this4.tangentX;
				_this4.tmpX = -_this4.aY;
				_this4.tmpY = _this4.aX;
				var miterLen = halfThick / (_this4.miterX * _this4.tmpX + _this4.miterY * _this4.tmpY);
				this.tangentX = polyline_Stroke.miterUtils.tangentX;
				this.tangentY = polyline_Stroke.miterUtils.tangentY;
				this.miterX = polyline_Stroke.miterUtils.miterX;
				this.miterY = polyline_Stroke.miterUtils.miterY;
				var flip = this.tangentX * this._normalX + this.tangentY * this._normalY < 0 ? -1 : 1;
				var bevel = joinBevel;
				if(!bevel && this.join == polyline_StrokeJoin.MITER) {
					var limit = miterLen / halfThick;
					if(limit > this.miterLimit) {
						bevel = true;
					}
				}
				if(bevel) {
					this.tmpX = curX1 + this._normalX * -halfThick * flip;
					this.tmpY = curY1 + this._normalY * -halfThick * flip;
					vertices.push(this.tmpX);
					vertices.push(this.tmpY);
					this.tmpX = curX1 + this.miterX * miterLen * flip;
					this.tmpY = curY1 + this.miterY * miterLen * flip;
					vertices.push(this.tmpX);
					vertices.push(this.tmpY);
					if(this._lastFlip != -flip) {
						indices.push(count);
						indices.push(count + 2);
						indices.push(count + 3);
					} else {
						indices.push(count + 2);
						indices.push(count + 1);
						indices.push(count + 3);
					}
					indices.push(count + 2);
					indices.push(count + 3);
					indices.push(count + 4);
					var _this5 = polyline_Stroke.miterUtils;
					_this5.outX = -this.lineBY;
					_this5.outY = this.lineBX;
					this.tmpX = polyline_Stroke.miterUtils.outX;
					this.tmpY = polyline_Stroke.miterUtils.outY;
					this._normalX = this.tmpX;
					this._normalY = this.tmpY;
					this.tmpX = curX1 + this.tmpX * -halfThick * flip;
					this.tmpY = curY1 + this.tmpY * -halfThick * flip;
					vertices.push(this.tmpX);
					vertices.push(this.tmpY);
					count1 += 3;
				} else {
					var normalX2 = this.miterX;
					var normalY2 = this.miterY;
					this.tmpX = curX1 + normalX2 * -miterLen;
					this.tmpY = curY1 + normalY2 * -miterLen;
					vertices.push(this.tmpX);
					vertices.push(this.tmpY);
					this.tmpX = curX1 + normalX2 * miterLen;
					this.tmpY = curY1 + normalY2 * miterLen;
					vertices.push(this.tmpX);
					vertices.push(this.tmpY);
					if(this._lastFlip == 1) {
						indices.push(count);
						indices.push(count + 2);
						indices.push(count + 3);
					} else {
						indices.push(count + 2);
						indices.push(count + 1);
						indices.push(count + 3);
					}
					flip = -1;
					this._normalX = this.miterX;
					this._normalY = this.miterY;
					count1 += 2;
				}
				this._lastFlip = flip;
			}
			var amt = count1;
			count += amt;
			i += 2;
		}
	}
	,mapThickness: function(pointX,pointY,i,points) {
		return this.thickness;
	}
	,_seg: function(vertices,indices,index,lastX,lastY,curX,curY,nextX,nextY,halfThick) {
		var count = 0;
		var capSquare = this.cap == polyline_StrokeCap.SQUARE;
		var joinBevel = this.join == polyline_StrokeJoin.BEVEL;
		polyline_Stroke.miterUtils.aX = curX;
		polyline_Stroke.miterUtils.aY = curY;
		polyline_Stroke.miterUtils.bX = lastX;
		polyline_Stroke.miterUtils.bY = lastY;
		var _this = polyline_Stroke.miterUtils;
		_this.outX = _this.aX - _this.bX;
		_this.outY = _this.aY - _this.bY;
		var len = _this.outX * _this.outX + _this.outY * _this.outY;
		if(len > 0) {
			len = 1.0 / Math.sqrt(len);
			_this.outX *= len;
			_this.outY *= len;
		}
		this.lineAX = polyline_Stroke.miterUtils.outX;
		this.lineAY = polyline_Stroke.miterUtils.outY;
		if(!this._hasNormal) {
			var _this1 = polyline_Stroke.miterUtils;
			_this1.outX = -this.lineAY;
			_this1.outY = this.lineAX;
			this._normalX = polyline_Stroke.miterUtils.outX;
			this._normalY = polyline_Stroke.miterUtils.outY;
			this._hasNormal = true;
		}
		if(!this._started) {
			this._started = true;
			if(capSquare) {
				this.capEndX = lastX + this.lineAX * -halfThick;
				this.capEndY = lastY + this.lineAY * -halfThick;
				lastX = this.capEndX;
				lastY = this.capEndY;
			}
			var normalX = this._normalX;
			var normalY = this._normalY;
			this.tmpX = lastX + normalX * -halfThick;
			this.tmpY = lastY + normalY * -halfThick;
			vertices.push(this.tmpX);
			vertices.push(this.tmpY);
			this.tmpX = lastX + normalX * halfThick;
			this.tmpY = lastY + normalY * halfThick;
			vertices.push(this.tmpX);
			vertices.push(this.tmpY);
		}
		indices.push(index);
		indices.push(index + 1);
		indices.push(index + 2);
		if(nextX == -9999999999.0) {
			var _this2 = polyline_Stroke.miterUtils;
			_this2.outX = -this.lineAY;
			_this2.outY = this.lineAX;
			this._normalX = polyline_Stroke.miterUtils.outX;
			this._normalY = polyline_Stroke.miterUtils.outY;
			this._hasNormal = true;
			if(capSquare) {
				this.capEndX = curX + this.lineAX * halfThick;
				this.capEndY = curY + this.lineAY * halfThick;
				curX = this.capEndX;
				curY = this.capEndY;
			}
			var normalX1 = this._normalX;
			var normalY1 = this._normalY;
			this.tmpX = curX + normalX1 * -halfThick;
			this.tmpY = curY + normalY1 * -halfThick;
			vertices.push(this.tmpX);
			vertices.push(this.tmpY);
			this.tmpX = curX + normalX1 * halfThick;
			this.tmpY = curY + normalY1 * halfThick;
			vertices.push(this.tmpX);
			vertices.push(this.tmpY);
			if(this._lastFlip == 1) {
				indices.push(index);
				indices.push(index + 2);
				indices.push(index + 3);
			} else {
				indices.push(index + 2);
				indices.push(index + 1);
				indices.push(index + 3);
			}
			count += 2;
		} else {
			polyline_Stroke.miterUtils.aX = nextX;
			polyline_Stroke.miterUtils.aY = nextY;
			polyline_Stroke.miterUtils.bX = curX;
			polyline_Stroke.miterUtils.bY = curY;
			var _this3 = polyline_Stroke.miterUtils;
			_this3.outX = _this3.aX - _this3.bX;
			_this3.outY = _this3.aY - _this3.bY;
			var len1 = _this3.outX * _this3.outX + _this3.outY * _this3.outY;
			if(len1 > 0) {
				len1 = 1.0 / Math.sqrt(len1);
				_this3.outX *= len1;
				_this3.outY *= len1;
			}
			this.lineBX = polyline_Stroke.miterUtils.outX;
			this.lineBY = polyline_Stroke.miterUtils.outY;
			polyline_Stroke.miterUtils.tangentX = this.tangentX;
			polyline_Stroke.miterUtils.tangentY = this.tangentY;
			polyline_Stroke.miterUtils.miterX = this.miterX;
			polyline_Stroke.miterUtils.miterY = this.miterY;
			polyline_Stroke.miterUtils.aX = this.lineAX;
			polyline_Stroke.miterUtils.aY = this.lineAY;
			polyline_Stroke.miterUtils.bX = this.lineBX;
			polyline_Stroke.miterUtils.bY = this.lineBY;
			var _this4 = polyline_Stroke.miterUtils;
			_this4.tangentX = _this4.aX + _this4.bX;
			_this4.tangentY = _this4.aY + _this4.bY;
			_this4.miterX = -_this4.tangentY;
			_this4.miterY = _this4.tangentX;
			_this4.tmpX = -_this4.aY;
			_this4.tmpY = _this4.aX;
			var miterLen = halfThick / (_this4.miterX * _this4.tmpX + _this4.miterY * _this4.tmpY);
			this.tangentX = polyline_Stroke.miterUtils.tangentX;
			this.tangentY = polyline_Stroke.miterUtils.tangentY;
			this.miterX = polyline_Stroke.miterUtils.miterX;
			this.miterY = polyline_Stroke.miterUtils.miterY;
			var flip = this.tangentX * this._normalX + this.tangentY * this._normalY < 0 ? -1 : 1;
			var bevel = joinBevel;
			if(!bevel && this.join == polyline_StrokeJoin.MITER) {
				var limit = miterLen / halfThick;
				if(limit > this.miterLimit) {
					bevel = true;
				}
			}
			if(bevel) {
				this.tmpX = curX + this._normalX * -halfThick * flip;
				this.tmpY = curY + this._normalY * -halfThick * flip;
				vertices.push(this.tmpX);
				vertices.push(this.tmpY);
				this.tmpX = curX + this.miterX * miterLen * flip;
				this.tmpY = curY + this.miterY * miterLen * flip;
				vertices.push(this.tmpX);
				vertices.push(this.tmpY);
				if(this._lastFlip != -flip) {
					indices.push(index);
					indices.push(index + 2);
					indices.push(index + 3);
				} else {
					indices.push(index + 2);
					indices.push(index + 1);
					indices.push(index + 3);
				}
				indices.push(index + 2);
				indices.push(index + 3);
				indices.push(index + 4);
				var _this5 = polyline_Stroke.miterUtils;
				_this5.outX = -this.lineBY;
				_this5.outY = this.lineBX;
				this.tmpX = polyline_Stroke.miterUtils.outX;
				this.tmpY = polyline_Stroke.miterUtils.outY;
				this._normalX = this.tmpX;
				this._normalY = this.tmpY;
				this.tmpX = curX + this.tmpX * -halfThick * flip;
				this.tmpY = curY + this.tmpY * -halfThick * flip;
				vertices.push(this.tmpX);
				vertices.push(this.tmpY);
				count += 3;
			} else {
				var normalX2 = this.miterX;
				var normalY2 = this.miterY;
				this.tmpX = curX + normalX2 * -miterLen;
				this.tmpY = curY + normalY2 * -miterLen;
				vertices.push(this.tmpX);
				vertices.push(this.tmpY);
				this.tmpX = curX + normalX2 * miterLen;
				this.tmpY = curY + normalY2 * miterLen;
				vertices.push(this.tmpX);
				vertices.push(this.tmpY);
				if(this._lastFlip == 1) {
					indices.push(index);
					indices.push(index + 2);
					indices.push(index + 3);
				} else {
					indices.push(index + 2);
					indices.push(index + 1);
					indices.push(index + 3);
				}
				flip = -1;
				this._normalX = this.miterX;
				this._normalY = this.miterY;
				count += 2;
			}
			this._lastFlip = flip;
		}
		return count;
	}
	,extrusions: function(vertices,pointX,pointY,normalX,normalY,scale) {
		this.tmpX = pointX + normalX * -scale;
		this.tmpY = pointY + normalY * -scale;
		vertices.push(this.tmpX);
		vertices.push(this.tmpY);
		this.tmpX = pointX + normalX * scale;
		this.tmpY = pointY + normalY * scale;
		vertices.push(this.tmpX);
		vertices.push(this.tmpY);
	}
};
var polyline_StrokeCap = { __ename__ : true, __constructs__ : ["BUTT","SQUARE"] };
polyline_StrokeCap.BUTT = ["BUTT",0];
polyline_StrokeCap.BUTT.__enum__ = polyline_StrokeCap;
polyline_StrokeCap.SQUARE = ["SQUARE",1];
polyline_StrokeCap.SQUARE.__enum__ = polyline_StrokeCap;
var polyline_StrokeJoin = { __ename__ : true, __constructs__ : ["MITER","BEVEL"] };
polyline_StrokeJoin.MITER = ["MITER",0];
polyline_StrokeJoin.MITER.__enum__ = polyline_StrokeJoin;
polyline_StrokeJoin.BEVEL = ["BEVEL",1];
polyline_StrokeJoin.BEVEL.__enum__ = polyline_StrokeJoin;
var polyline_Test = function() { };
polyline_Test.__name__ = true;
polyline_Test.main = function() {
	var points = [25,25,15,60];
	var stroke = new polyline_Stroke();
	stroke.thickness = 20;
	stroke.cap = polyline_StrokeCap.SQUARE;
	stroke.join = polyline_StrokeJoin.BEVEL;
	stroke.miterLimit = 10;
	var vertices = [];
	var indices = [];
	stroke.build(points,vertices,indices);
	console.log("Test.hx:20:",vertices);
	console.log("Test.hx:21:",indices);
};
String.__name__ = true;
Array.__name__ = true;
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
polyline_Stroke.NUMBER_NONE = -9999999999.0;
polyline_Stroke.miterUtils = new polyline_MiterUtils();
polyline_Test.main();
})();
